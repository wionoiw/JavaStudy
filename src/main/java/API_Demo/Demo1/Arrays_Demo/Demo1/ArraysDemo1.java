package API_Demo.Demo1.Arrays_Demo.Demo1;

/**
 * @Author HHH
 * @Date 2025/4/20 18:20
 * @Day Day23
 */

//Arrays类
//操作数组的工具类

//public static String toString(数组)                          把数组拼接成一个字符串
    //格式为[元素一,元素二,元素三]
//public static int binarySearch(数组,查找的元素)                二分查找法查找元素
    //数组中的元素必须是升序的
    //如果要查找的元素是存在的,那么返回的是真实的索引
    //但是如果要查找的元素是不存在的,返回的是 -插入点-1        //插入点:将不存在的元素插入数组时其应存在的索引
        //为什么要减1呢
            //如果要查找数字0,但0是不存在的,按照上面的规则-插入点,应该就是-0,会造成误解
            //为了避免这样的情况，Java在这个基础上又减一
//public static int[] copyOf(原数组,新数组长度)                   拷贝数组
//public static int[] copyOfRange(原数组,起始索引,结束索引)      拷贝数组 (指定范围)   //包头不包尾
//public static void fill(数组,元素)                            填充数组
    //将数组所有位置填充为指定元素,不论原来是否有值
//public static void sort(数组)                                按照默认方式进行数组排序
    //sort:排序   默认情况下,给基本数据类型进行升序排列     底层使用的是快速排序。
//public static void sort(数组,Comparator<? super T> c)                         按照指定的规则排序
    //c指排序规则,Comparator是一个接口,需要传入一个实现类对象,作为排序的规则
    //但是这个实现类，我只要使用一次，所以就没有必要单独的去写一个类,直接采取匿名内部类的方式就可以了
    //如果是对基本数据类型排序,创建Comparator实现类对象时需要传入对应包装类

    //创建Comparator实现类对象需要重载的抽象方法
//    new Comparator<Integer>() {
//        @Override
//        public int compare(Integer o1, Integer o2){
//            return 0;
//        }
//     }

    //compare方法的形式参数:
    //参数一o1:表示在无序序列中，遍历得到的每一个元素
    //参数二o2:有序序列中的元素
    //返回值:
    //负数:表示当前要插入的元素是小的，放在前面
    //正数:表示当前要插入的元素是大的，放在后面
    //0:表示当前要插入的元素跟现在的元素是一样的,也会放在后面
    //即返回值为 o1 - o2 升序排列
    //         o2 - o1 降序排列

    //底层原理：
    //利用插入排序+二分查找的方式进行排序的。
    //默认把0索引的数据当做是有序的序列,1索引到最后认为是无序的序列。
    //遍历无序的序列得到里面的每一个元素，假设当前遍历得到的元素是A元素
    //把A往有序序列中进行插入,在插入的时候,是利用二分查找确定A元素的插入点。
    //拿着A元素,跟插入点的元素进行比较，比较的规则就是compare方法的方法体
    //如果方法的返回值是负数,拿着A继续跟前面的数据进行比较
    //如果方法的返回值是正数,拿着A继续跟后面的数据进行比较
    //如果方法的返回值是0,也拿着A跟后面的数据进行比较
    //直到能确定A的最终位置为止
public class ArraysDemo1 {
}
